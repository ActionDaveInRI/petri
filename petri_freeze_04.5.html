<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Emergent Petri Dish Simulator – Evo Traits & Radiation Lethality</title>
  <style>
    body { margin: 0; overflow: hidden; background-color: #101010; }
    canvas { display: block; }
    /* Draggable, semitransparent control panel */
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 8px;
      color: #fff;
      font-family: sans-serif;
      font-size: 14px;
      z-index: 10;
      max-width: 300px;
      cursor: move;
    }
    /* Start with the control panel collapsed */
    #controls.minimized #controlsContent { display: none; }
    /* Header for the control panel */
    #controlsHeader {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    #controlsHeader span { font-weight: bold; }
    #minimizeButton {
      background: transparent;
      border: none;
      color: #fff;
      font-size: 16px;
      cursor: pointer;
    }
    /* Debug panel moved to upper right */
    #debug {
      position: absolute;
      top: 10px;
      right: 10px;
      color: lime;
      font-family: monospace;
      font-size: 12px;
      z-index: 10;
      background: rgba(0,0,0,0.5);
      padding: 4px;
    }
    /* Tooltip for gene info */
    #tooltip {
      position: absolute;
      pointer-events: none;
      background: rgba(0,0,0,0.7);
      color: #fff;
      font-family: monospace;
      font-size: 12px;
      padding: 4px;
      border-radius: 4px;
      display: none;
      z-index: 20;
    }
    .control-group { margin-bottom: 10px; }
    .control-group label { display: inline-block; width: 150px; }
    .control-group input[type="range"] { width: 120px; }
    .control-group button { margin-right: 5px; }
  </style>
</head>
<body>
  <!-- Draggable & Minimizable Control Panel (default collapsed) -->
  <div id="controls" class="minimized">
    <div id="controlsHeader">
      <span>Control Panel</span>
      <button id="minimizeButton">☰</button>
    </div>
    <div id="controlsContent">
      <div class="control-group">
        <label for="speedControl">Simulation Speed:</label>
        <input id="speedControl" type="range" min="0" max="3" step="0.001" value="1">
        <span id="speedDisplay">1.000</span>
      </div>
      <div class="control-group">
        <label for="mutationSlider">Mutation Multiplier:</label>
        <input id="mutationSlider" type="range" min="0.1" max="3" step="0.1" value="1.0">
        <span id="mutationDisplay">1.0</span>
      </div>
      <div class="control-group">
        <label for="photosynthesisSlider">Goo Photosynthesis Rate:</label>
        <input id="photosynthesisSlider" type="range" min="0.005" max="0.05" step="0.001" value="0.02">
        <span id="photosynthesisDisplay">0.02</span>
      </div>
      <div class="control-group">
        <label for="hairyNibbleSlider">Hairy Nibble Prob.:</label>
        <input id="hairyNibbleSlider" type="range" min="0.05" max="0.50" step="0.01" value="0.20">
        <span id="hairyNibbleDisplay">0.20</span>
      </div>
      <div class="control-group">
        <label for="shellyNibbleSlider">Shelly Nibble Prob.:</label>
        <input id="shellyNibbleSlider" type="range" min="0.01" max="0.10" step="0.01" value="0.03">
        <span id="shellyNibbleDisplay">0.03</span>
      </div>
      <div class="control-group">
        <label for="shellyEnergySlider">Shelly Initial Energy:</label>
        <input id="shellyEnergySlider" type="range" min="10" max="120" step="1" value="80">
        <span id="shellyEnergyDisplay">80</span>
      </div>
      <div class="control-group">
        <label for="hairyEnergySlider">Hairy Initial Energy:</label>
        <input id="hairyEnergySlider" type="range" min="10" max="100" step="1" value="50">
        <span id="hairyEnergyDisplay">50</span>
      </div>
      <div class="control-group">
        <label for="hairyVsHairySlider">Hairy vs. Hairy Damage Prob.:</label>
        <input id="hairyVsHairySlider" type="range" min="0.05" max="0.5" step="0.01" value="0.20">
        <span id="hairyVsHairyDisplay">0.20</span>
      </div>
      <div class="control-group">
        <button id="placeGoo">Place Goo</button>
        <button id="placeHairy">Place Hairy</button>
        <button id="placeShelly">Place Shelly</button>
      </div>
      <div class="control-group">
        <button id="resetDefaults">Reset Defaults</button>
      </div>
      <div class="control-group">
        <small>Click canvas for radiation if not placing a critter</small>
      </div>
    </div>
  </div>
  
  <!-- Population counter and tooltip -->
  <div id="debug">Population: 0</div>
  <div id="tooltip"></div>
  <canvas></canvas>
  
  <script>
    /***********************
     * SETUP & CONTROLS
     ***********************/
    const canvas = document.querySelector('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    // Global adjustable parameters
    let simulationSpeed = parseFloat(document.getElementById('speedControl').value);
    let GLOBAL_MUTATION_MULTIPLIER = parseFloat(document.getElementById('mutationSlider').value);
    let GOO_PHOTOSYNTHESIS_RATE = parseFloat(document.getElementById('photosynthesisSlider').value);
    let HAIRY_NIBBLE_PROBABILITY = parseFloat(document.getElementById('hairyNibbleSlider').value);
    let SHELLY_NIBBLE_PROBABILITY = parseFloat(document.getElementById('shellyNibbleSlider').value);
    let SHELLY_INITIAL_ENERGY = parseFloat(document.getElementById('shellyEnergySlider').value);
    let HAIRY_INITIAL_ENERGY = parseFloat(document.getElementById('hairyEnergySlider').value);
    let HAIRY_VS_HAIRY_DAMAGE_PROBABILITY = parseFloat(document.getElementById('hairyVsHairySlider').value);
    
    // Update slider displays
    const speedDisplay = document.getElementById('speedDisplay');
    const mutationDisplay = document.getElementById('mutationDisplay');
    const photosynthesisDisplay = document.getElementById('photosynthesisDisplay');
    const hairyNibbleDisplay = document.getElementById('hairyNibbleDisplay');
    const shellyNibbleDisplay = document.getElementById('shellyNibbleDisplay');
    const shellyEnergyDisplay = document.getElementById('shellyEnergyDisplay');
    const hairyEnergyDisplay = document.getElementById('hairyEnergyDisplay');
    const hairyVsHairyDisplay = document.getElementById('hairyVsHairyDisplay');
    
    function updateSliderDisplays() {
      speedDisplay.textContent = simulationSpeed.toFixed(3);
      mutationDisplay.textContent = GLOBAL_MUTATION_MULTIPLIER.toFixed(1);
      photosynthesisDisplay.textContent = GOO_PHOTOSYNTHESIS_RATE.toFixed(3);
      hairyNibbleDisplay.textContent = HAIRY_NIBBLE_PROBABILITY.toFixed(2);
      shellyNibbleDisplay.textContent = SHELLY_NIBBLE_PROBABILITY.toFixed(2);
      shellyEnergyDisplay.textContent = SHELLY_INITIAL_ENERGY.toFixed(0);
      hairyEnergyDisplay.textContent = HAIRY_INITIAL_ENERGY.toFixed(0);
      hairyVsHairyDisplay.textContent = HAIRY_VS_HAIRY_DAMAGE_PROBABILITY.toFixed(2);
    }
    
    updateSliderDisplays();
    
    document.getElementById('speedControl').addEventListener("input", (e) => {
      simulationSpeed = parseFloat(e.target.value);
      speedDisplay.textContent = simulationSpeed.toFixed(3);
    });
    document.getElementById('mutationSlider').addEventListener("input", (e) => {
      GLOBAL_MUTATION_MULTIPLIER = parseFloat(e.target.value);
      mutationDisplay.textContent = GLOBAL_MUTATION_MULTIPLIER.toFixed(1);
    });
    document.getElementById('photosynthesisSlider').addEventListener("input", (e) => {
      GOO_PHOTOSYNTHESIS_RATE = parseFloat(e.target.value);
      photosynthesisDisplay.textContent = GOO_PHOTOSYNTHESIS_RATE.toFixed(3);
    });
    document.getElementById('hairyNibbleSlider').addEventListener("input", (e) => {
      HAIRY_NIBBLE_PROBABILITY = parseFloat(e.target.value);
      hairyNibbleDisplay.textContent = HAIRY_NIBBLE_PROBABILITY.toFixed(2);
    });
    document.getElementById('shellyNibbleSlider').addEventListener("input", (e) => {
      SHELLY_NIBBLE_PROBABILITY = parseFloat(e.target.value);
      shellyNibbleDisplay.textContent = SHELLY_NIBBLE_PROBABILITY.toFixed(2);
    });
    document.getElementById('shellyEnergySlider').addEventListener("input", (e) => {
      SHELLY_INITIAL_ENERGY = parseFloat(e.target.value);
      shellyEnergyDisplay.textContent = SHELLY_INITIAL_ENERGY.toFixed(0);
    });
    document.getElementById('hairyEnergySlider').addEventListener("input", (e) => {
      HAIRY_INITIAL_ENERGY = parseFloat(e.target.value);
      hairyEnergyDisplay.textContent = HAIRY_INITIAL_ENERGY.toFixed(0);
    });
    document.getElementById('hairyVsHairySlider').addEventListener("input", (e) => {
      HAIRY_VS_HAIRY_DAMAGE_PROBABILITY = parseFloat(e.target.value);
      hairyVsHairyDisplay.textContent = HAIRY_VS_HAIRY_DAMAGE_PROBABILITY.toFixed(2);
    });
    
    document.getElementById('resetDefaults').addEventListener("click", () => {
      document.getElementById('speedControl').value = 1;
      simulationSpeed = 1;
      document.getElementById('mutationSlider').value = 1.0;
      GLOBAL_MUTATION_MULTIPLIER = 1.0;
      document.getElementById('photosynthesisSlider').value = 0.02;
      GOO_PHOTOSYNTHESIS_RATE = 0.02;
      document.getElementById('hairyNibbleSlider').value = 0.20;
      HAIRY_NIBBLE_PROBABILITY = 0.20;
      document.getElementById('shellyNibbleSlider').value = 0.03;
      SHELLY_NIBBLE_PROBABILITY = 0.03;
      document.getElementById('shellyEnergySlider').value = 80;
      SHELLY_INITIAL_ENERGY = 80;
      document.getElementById('hairyEnergySlider').value = 50;
      HAIRY_INITIAL_ENERGY = 50;
      document.getElementById('hairyVsHairySlider').value = 0.20;
      HAIRY_VS_HAIRY_DAMAGE_PROBABILITY = 0.20;
      updateSliderDisplays();
    });
    
    const debugDiv = document.getElementById('debug');
    const tooltipDiv = document.getElementById('tooltip');
    
    // World parameters:
    const zoom = 0.6;
    const worldSize = { width: canvas.width * zoom, height: canvas.height * zoom };
    
    /***********************
     * GLOBAL VARIABLES & CONSTANTS
     ***********************/
    let particles = [];           // All critters
    let poops = [];               // Poop objects
    let radioactiveZones = [];    // Radiation zones
    const maxPopulation = 300;
    const NEWBORN_IMMUNITY_DURATION = 80;
    
    // Placement mode globals:
    let placementMode = false;
    let placementType = null; // 0: Goo, 1: Hairy, 2: Shelly
    
    document.getElementById('placeGoo').addEventListener("click", () => {
      placementMode = true;
      placementType = 0;
      console.log("Placement mode: Place Goo. Click on canvas to place it.");
    });
    document.getElementById('placeHairy').addEventListener("click", () => {
      placementMode = true;
      placementType = 1;
      console.log("Placement mode: Place Hairy. Click on canvas to place it.");
    });
    document.getElementById('placeShelly').addEventListener("click", () => {
      placementMode = true;
      placementType = 2;
      console.log("Placement mode: Place Shelly. Click on canvas to place it.");
    });
    
    /***********************
     * DRAGGABLE & MINIMIZABLE CONTROL PANEL
     ***********************/
    const controls = document.getElementById('controls');
    const minimizeButton = document.getElementById('minimizeButton');
    let isDragging = false, dragOffsetX = 0, dragOffsetY = 0;
    document.getElementById('controlsHeader').addEventListener('mousedown', (e) => {
      isDragging = true;
      dragOffsetX = e.clientX - controls.offsetLeft;
      dragOffsetY = e.clientY - controls.offsetTop;
    });
    document.addEventListener('mousemove', (e) => {
      if (isDragging) {
        controls.style.left = (e.clientX - dragOffsetX) + 'px';
        controls.style.top = (e.clientY - dragOffsetY) + 'px';
      }
    });
    document.addEventListener('mouseup', () => { isDragging = false; });
    minimizeButton.addEventListener('click', () => {
      controls.classList.toggle('minimized');
      minimizeButton.textContent = controls.classList.contains('minimized') ? "☰" : "–";
    });
    
    /***********************
     * HELPER FUNCTIONS
     ***********************/
    function clamp(value, min, max) {
      return Math.min(max, Math.max(min, value));
    }
    
    // For Goo, scale max energy by size.
    function addEnergy(particle, amount) {
      let max;
      if (particle.type === 0) {
        max = 80 * (particle.size / 8);
      } else if (particle.type === 1) {
        max = 100;
      } else if (particle.type === 2) {
        max = 120;
      }
      particle.energy = Math.min(particle.energy + amount, max);
    }
    
    function getTrait(particle, geneName, base) {
      return 1 + (particle.dna[geneName] - base) / 20;
    }
    
    function getToughnessThreshold(particle) {
      if (particle.type === 0) {
        return (particle.dna.subHue >= 130) ? 4 : 3;
      } else if (particle.type === 1) {
        return (particle.dna.detailHue < -5) ? 4 : 3;
      } else if (particle.type === 2) {
        return (particle.dna.detailHue > 245) ? 4 : 3;
      }
      return 3;
    }
    
    /***********************
     * SPIKE HUE MAPPING FUNCTION
     ***********************/
    // We assume spikeHue is in the range [0, 120] with 60 as neutral (yellow).
    // For spikeHue below 60, map from yellow (60°) to green (around 120°).
    // For spikeHue above 60, map from yellow (60°) to red (0°).
    function mapSpikeHueToColor(spikeHue) {
      if (spikeHue <= 60) {
        // When spikeHue is 60, return 60 (yellow); when 0, return 120 (green).
        return 120 - spikeHue; // Linear mapping: 0 -> 120, 60 -> 60.
      } else {
        // When spikeHue is 60, return 60; when 120, return 0 (red).
        return 60 - (spikeHue - 60); // Linear mapping: 60 -> 60, 120 -> 0.
      }
    }
    
    /***********************
     * CRITTER DEFINITIONS
     ***********************/
    const particleTypes = [
      {
        name: "Goo",
        draw: (ctx, x, y, particle) => {
          const baseSize = particle.size;
          // Goo "pulses" with three orbs.
          for (let i = 0; i < 3; i++) {
            const angle = i * (2 * Math.PI / 3);
            const pulse = 1 + 0.1 * Math.sin(particle.age * 0.1 + i);
            const orbSize = baseSize * pulse;
            const offset = baseSize * 1.0;
            const orbX = x + offset * Math.cos(angle);
            const orbY = y + offset * Math.sin(angle);
            let gene = particle.dna[i === 0 ? "mainHue" : i === 1 ? "subHue" : "detailHue"];
            let light = 50 + (((gene % 1) - 0.5) * 30);
            ctx.fillStyle = `hsla(${gene},70%,${light}%,0.85)`;
            ctx.beginPath();
            ctx.arc(orbX, orbY, orbSize, 0, 2 * Math.PI);
            ctx.fill();
          }
          ctx.strokeStyle = `hsl(100,50%,30%)`;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x, y + baseSize * 0.5);
          ctx.stroke();
        },
        behavior: (particle) => {
          // Goo remain stationary.
          particle.vx = 0;
          particle.vy = 0;
        }
      },
      {
        name: "Hairy",
        draw: (ctx, x, y, particle) => {
          const size = particle.size;
          // Draw the main body using mainHue and subHue.
          ctx.fillStyle = `hsl(${particle.dna.mainHue},80%,50%)`;
          ctx.beginPath();
          ctx.arc(x, y, size, 0, 2 * Math.PI);
          ctx.fill();
          ctx.fillStyle = `hsl(${particle.dna.subHue},80%,50%)`;
          ctx.beginPath();
          ctx.arc(x, y, size * 0.5, 0, 2 * Math.PI);
          ctx.fill();
          
          // Use detailHue to determine spike brightness/thickness.
          let aggressionFactor = clamp((particle.dna.detailHue - 100) / 40, 0, 1);
          let hairLineWidth = 1 + 3 * aggressionFactor;
          let hairBrightness = 50 + 20 * aggressionFactor;
          
          // Map the spikeHue (our combat trait) into a color.
          let mappedHue = mapSpikeHueToColor(particle.dna.spikeHue);
          let spikeColor = `hsl(${mappedHue},100%,${hairBrightness}%)`;
          
          ctx.strokeStyle = spikeColor;
          ctx.lineWidth = hairLineWidth;
          for (let i = 0; i < 8; i++) {
            const angle = (2 * Math.PI * i) / 8;
            const lx = x + Math.cos(angle) * (size + 4);
            const ly = y + Math.sin(angle) * (size + 4);
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(lx, ly);
            ctx.stroke();
          }
          
          if (particle.predationCue > 0) {
            ctx.strokeStyle = "yellow";
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(x, y, size + 4, 0, 2 * Math.PI);
            ctx.stroke();
          }
        },
        behavior: (particle) => {
          // Agility based on subHue.
          let agility = getTrait(particle, "subHue", 120);
          particle.vx += (Math.random() - 0.5) * agility / particle.size * 0.01;
          particle.vy += (Math.random() - 0.5) * agility / particle.size * 0.01;
          let target = null, minDist = 100;
          for (let other of particles) {
            if (other.type === 2) {
              const dx = other.x - particle.x;
              const dy = other.y - particle.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              if (dist < minDist) { minDist = dist; target = other; }
            }
          }
          if (target) {
            const dx = target.x - particle.x;
            const dy = target.y - particle.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist > 0) {
              if (dist < 15 && Math.random() < HAIRY_NIBBLE_PROBABILITY) {
                if (dist < 10) {
                  // Incorporate spikeHue into the damage calculation.
                  let spikeFactor = 1 + (particle.dna.spikeHue - 60) / 50;
                  let nibbleAmount = 5 * (target.size / 10) * spikeFactor;
                  target.energy -= nibbleAmount;
                  addEnergy(particle, nibbleAmount);
                  particle.predationCue = 30;
                  if (target.energy <= 0) {
                    let index = particles.indexOf(target);
                    if (index !== -1) particles.splice(index, 1);
                  }
                }
              } else {
                particle.vx += (dx / dist) * 0.005;
                particle.vy += (dy / dist) * 0.005;
              }
            }
          }
          // Additional behavior: repulsion from poops and interactions with other Hairy critters.
          for (let poop of poops) {
            const dx = particle.x - poop.x;
            const dy = particle.y - poop.y;
            const d = Math.sqrt(dx * dx + dy * dy);
            if (d < 50 && d > 0) {
              const rep = 0.05 * (1 - d / 50);
              particle.vx += (dx / d) * rep;
              particle.vy += (dy / d) * rep;
            }
          }
          let localPoopCount = 0, sumX = 0, sumY = 0;
          for (let poop of poops) {
            const dx = particle.x - poop.x;
            const dy = particle.y - poop.y;
            const d = Math.sqrt(dx * dx + dy * dy);
            if (d < 50) { localPoopCount++; sumX += poop.x; sumY += poop.y; }
          }
          if (localPoopCount > 3) {
            let extraForce = (localPoopCount - 3) * 0.01;
            let centerX = sumX / localPoopCount, centerY = sumY / localPoopCount;
            let dx = particle.x - centerX, dy = particle.y - centerY;
            let d = Math.sqrt(dx * dx + dy * dy);
            if (d > 0) {
              particle.vx += (dx / d) * extraForce;
              particle.vy += (dy / d) * extraForce;
            }
          }
          if (particle.age >= NEWBORN_IMMUNITY_DURATION) {
            for (let other of particles) {
              if (other.type === 2) {
                const dx = particle.x - other.x;
                const dy = particle.y - other.y;
                const d = Math.sqrt(dx * dx + dy * dy);
                if (d < 10 && Math.random() < 0.02) {
                  particle.energy -= 1;
                  particle.predationCue = 30;
                }
              }
            }
          }
          if (particle.age >= NEWBORN_IMMUNITY_DURATION) {
            for (let other of particles) {
              if (other.type === 1 && other !== particle && other.age >= NEWBORN_IMMUNITY_DURATION) {
                const dx = particle.x - other.x;
                const dy = particle.y - other.y;
                const d = Math.sqrt(dx * dx + dy * dy);
                if (d < 20) {
                  let r = Math.random();
                  if (r < HAIRY_VS_HAIRY_DAMAGE_PROBABILITY) {
                    particle.energy -= 5;
                    other.energy -= 5;
                    particle.predationCue = 30;
                    other.predationCue = 30;
                  } else if (r < 0.9) {
                    let repulsionForce = 0.05;
                    particle.vx += (dx / d) * repulsionForce;
                    particle.vy += (dy / d) * repulsionForce;
                    other.vx -= (dx / d) * repulsionForce;
                    other.vy -= (dy / d) * repulsionForce;
                  }
                }
              }
            }
          }
        }
      },
      {
        name: "Shelly",
        draw: (ctx, x, y, particle) => {
          const size = particle.size;
          ctx.fillStyle = `hsl(${particle.dna.mainHue},70%,30%)`;
          ctx.beginPath();
          for (let i = 0; i < 6; i++) {
            const angle = (2 * Math.PI * i) / 6;
            const px = x + Math.cos(angle) * size;
            const py = y + Math.sin(angle) * size;
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
          }
          ctx.closePath();
          ctx.fill();
          ctx.fillStyle = `hsl(${particle.dna.subHue},80%,70%)`;
          ctx.beginPath();
          ctx.arc(x, y, size * 0.5, 0, 2 * Math.PI);
          ctx.fill();
          ctx.fillStyle = `hsl(${particle.dna.detailHue},90%,50%)`;
          ctx.beginPath();
          ctx.arc(x, y, size * 0.2, 0, 2 * Math.PI);
          ctx.fill();
          if (particle.predationCue > 0) {
            ctx.strokeStyle = "cyan";
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(x, y, size + 4, 0, 2 * Math.PI);
            ctx.stroke();
          }
        },
        behavior: (particle) => {
          let evasion = getTrait(particle, "subHue", 120);
          particle.vx += (Math.random() - 0.5) * evasion / particle.size * 0.01;
          particle.vy += (Math.random() - 0.5) * evasion / particle.size * 0.01;
          let target = null, minDist = 100;
          for (let other of particles) {
            if (other.type === 0) {
              const dx = other.x - particle.x;
              const dy = other.y - particle.y;
              const d = Math.sqrt(dx * dx + dy * dy);
              if (d < minDist) { minDist = d; target = other; }
            }
          }
          if (target) {
            const dx = target.x - particle.x;
            const dy = target.y - particle.y;
            const d = Math.sqrt(dx * dx + dy * dy);
            if (d > 0) {
              particle.vx += (dx / d) * 0.02;
              particle.vy += (dy / d) * 0.02;
            }
          }
          for (let poop of poops) {
            const dx = particle.x - poop.x;
            const dy = particle.y - poop.y;
            const d = Math.sqrt(dx * dx + dy * dy);
            if (d < 50 && d > 0) {
              const rep = 0.05 * (1 - d / 50);
              particle.vx += (dx / d) * rep;
              particle.vy += (dy / d) * rep;
            }
          }
        }
      }
    ];
    
    /***********************
     * HELPER: Create Particle of a Given Type
     ***********************/
    function createParticleOfType(type) {
      let baseHue, baseSubHue, baseDetailHue, baseSpikeHue;
      if (type === 0) { // Goo
        baseHue = 120; baseSubHue = 120; baseDetailHue = 120;
      } else if (type === 1) { // Hairy
        // Set default values for Hairy critters:
        baseHue = 0;       // Behavior Hue (aggressive if redder)
        baseSubHue = 0;      // Agility
        baseDetailHue = 60;  // Fighting Persistence
        baseSpikeHue = 60;   // Spike Combat Efficiency (60 = yellow, neutral)
      } else if (type === 2) { // Shelly
        baseHue = 240; baseSubHue = 200; baseDetailHue = 220;
      }
      
      let initialEnergy, reproductionCooldown;
      if (type === 0) {
        initialEnergy = 40; reproductionCooldown = 200;
      } else if (type === 1) {
        initialEnergy = HAIRY_INITIAL_ENERGY; reproductionCooldown = 300;
      } else if (type === 2) {
        initialEnergy = SHELLY_INITIAL_ENERGY; reproductionCooldown = 100;
      }
      
      let size = (type === 0) ? 8 : 10;
      return {
        x: Math.random() * worldSize.width,
        y: Math.random() * worldSize.height,
        vx: (Math.random() - 0.5) * 2,
        vy: (Math.random() - 0.5) * 2,
        type: type,
        age: Math.random() * 100,
        size: size,
        mutationRate: 0.2 + Math.random() * 0.1,
        reproductionCooldown: reproductionCooldown,
        predationCue: 0,
        radiationCue: 0,
        absorbCue: 0,
        energy: initialEnergy,
        radiationExposureCount: 0,
        dna: {
          mainHue: baseHue,
          subHue: baseSubHue,
          detailHue: baseDetailHue,
          spikeHue: (type === 1 ? baseSpikeHue : baseDetailHue)
        }
      };
    }
    
    function createParticleAtLocation(type, x, y) {
      let p = createParticleOfType(type);
      p.x = x;
      p.y = y;
      return p;
    }
    
    /***********************
     * INITIALIZATION FUNCTION
     ***********************/
    function initializeParticles(count = 150) {
      particles = [];
      particles.push(createParticleOfType(1));
      particles.push(createParticleOfType(2));
      particles.push(createParticleOfType(2));
      while (particles.length < count) {
        particles.push(createParticleOfType(0));
      }
    }
    initializeParticles(150);
    
    /***********************
     * GLOBAL EVOLUTION TIMER
     ***********************/
    let globalTime = 0;
    
    /***********************
     * GENETIC & REPRODUCTION HELPERS
     ***********************/
    function mutateParticle(particle, factor = 1, forced = false) {
      const mutationStrength = particle.mutationRate * GLOBAL_MUTATION_MULTIPLIER * factor * 0.1;
      particle.size += (Math.random() - 0.5) * mutationStrength;
      particle.size = clamp(particle.size, 4, 20);
      if (forced) {
        let multiplier = (particle.type !== 0) ? 3 : 2;
        particle.dna.mainHue += (Math.random() - 0.5) * mutationStrength * multiplier;
        particle.dna.subHue += (Math.random() - 0.5) * mutationStrength * multiplier;
        particle.dna.detailHue += (Math.random() - 0.5) * mutationStrength * multiplier;
        if (particle.type === 1) {
          // Also mutate spikeHue independently for Hairy critters.
          particle.dna.spikeHue += (Math.random() - 0.5) * mutationStrength * multiplier;
        }
        if (particle.type === 0) {
          particle.dna.mainHue = clamp(particle.dna.mainHue, 75, 145);
          particle.dna.subHue = clamp(particle.dna.subHue, 75, 145);
          particle.dna.detailHue = clamp(particle.dna.detailHue, 75, 145);
        }
      }
    }
    
    function reproduceParticle(parent) {
      return {
        x: parent.x + (Math.random() - 0.5) * 20,
        y: parent.y + (Math.random() - 0.5) * 20,
        vx: (Math.random() - 0.5) * 2,
        vy: (Math.random() - 0.5) * 2,
        type: parent.type,
        age: 0,
        size: parent.size,
        mutationRate: parent.mutationRate,
        reproductionCooldown: (parent.type === 0) ? 200 : (parent.type === 1 ? 200 : 100),
        predationCue: 0,
        radiationCue: 0,
        energy: 40,
        radiationExposureCount: 0,
        dna: {
          mainHue: parent.dna.mainHue + (Math.random() - 0.5) * 10,
          subHue: parent.dna.subHue + (Math.random() - 0.5) * 10,
          detailHue: parent.dna.detailHue + (Math.random() - 0.5) * 10,
          spikeHue: (parent.type === 1 ? parent.dna.spikeHue + (Math.random() - 0.5) * 10 : parent.dna.detailHue)
        }
      };
    }
    
    /***********************
     * RADIATION (CLICK) / PLACEMENT EFFECT
     ***********************/
    canvas.addEventListener("click", (e) => {
      const rect = canvas.getBoundingClientRect();
      const clickX = (e.clientX - rect.left) * zoom;
      const clickY = (e.clientY - rect.top) * zoom;
      if (placementMode) {
        particles.push(createParticleAtLocation(placementType, clickX, clickY));
        placementMode = false;
      } else {
        radioactiveZones.push({ x: clickX, y: clickY, radius: 75, lifetime: 300 });
        particles = particles.filter(particle => {
          const dx = particle.x - clickX;
          const dy = particle.y - clickY;
          const d = Math.sqrt(dx * dx + dy * dy);
          if (d < 75) {
            particle.radiationExposureCount++;
            if (particle.radiationExposureCount >= getToughnessThreshold(particle)) {
              return false;
            }
          }
          return true;
        });
      }
    });
    
    /***********************
     * NEW POOP GRAPHIC
     ***********************/
    function createProcGenPoop(x, y, creatureSize) {
      const numPoints = 12;
      const points = [];
      for (let i = 0; i < numPoints; i++) {
        points.push(0.8 + 0.4 * Math.random());
      }
      return { x: x, y: y, lifetime: 500, radius: creatureSize * 0.5, points: points };
    }
    
    function drawProcGenPoop(ctx, poop) {
      const x = poop.x / zoom;
      const y = poop.y / zoom;
      const r = poop.radius / zoom;
      ctx.save();
      ctx.translate(x, y);
      ctx.beginPath();
      const total = poop.points.length;
      for (let i = 0; i < total; i++) {
        const angle = i * (2 * Math.PI / total);
        let offset = r + r * 0.2 * Math.sin(angle * 3 + poop.points[i]);
        let px = offset * Math.cos(angle);
        let py = offset * Math.sin(angle);
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();
      let grad = ctx.createRadialGradient(0, 0, r * 0.2, 0, 0, r);
      grad.addColorStop(0, "#5b3a21");
      grad.addColorStop(0.5, "#8b4513");
      grad.addColorStop(1, "#a67c52");
      ctx.fillStyle = grad;
      ctx.fill();
      ctx.restore();
    }
    
    /***********************
     * MAIN SIMULATION LOOP
     ***********************/
    function update() {
      ctx.fillStyle = "rgba(16,16,16,0.95)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      for (let i = radioactiveZones.length - 1; i >= 0; i--) {
        const zone = radioactiveZones[i];
        zone.lifetime -= simulationSpeed;
        ctx.strokeStyle = `rgba(255,0,0,${zone.lifetime/300})`;
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(zone.x / zoom, zone.y / zoom, zone.radius / zoom, 0, 2 * Math.PI);
        ctx.stroke();
        if (zone.lifetime <= 0) {
          radioactiveZones.splice(i, 1);
        }
      }
      
      for (let i = poops.length - 1; i >= 0; i--) {
        const poop = poops[i];
        poop.lifetime -= 1;
        drawProcGenPoop(ctx, poop);
        if (poop.lifetime <= 0) poops.splice(i, 1);
      }
      
      for (let i = particles.length - 1; i >= 0; i--) {
        let particle = particles[i];
        
        if (particle.type === 0) {
          const mutationStrength = particle.mutationRate * GLOBAL_MUTATION_MULTIPLIER * simulationSpeed * 0.1;
          particle.size += (Math.random() - 0.5) * mutationStrength;
          particle.size = clamp(particle.size, 4, 20);
        } else {
          mutateParticle(particle, simulationSpeed, false);
        }
        
        particle.energy -= 0.01 * simulationSpeed;
        if (particle.energy < 0) particle.energy = 0;
        particle.reproductionCooldown -= simulationSpeed;
        particle.age += simulationSpeed;
        
        if (particle.type === 0) {
          addEnergy(particle, GOO_PHOTOSYNTHESIS_RATE * simulationSpeed * 10);
        }
        
        for (let zone of radioactiveZones) {
          const dx = particle.x - zone.x;
          const dy = particle.y - zone.y;
          const d = Math.sqrt(dx * dx + dy * dy);
          if (d < zone.radius) {
            let radFactor = 5 + Math.random() * 5;
            mutateParticle(particle, radFactor * simulationSpeed, true);
            particle.radiationCue = 30;
          }
        }
        
        if (particle.type === 2) {
          for (let j = particles.length - 1; j >= 0; j--) {
            let other = particles[j];
            if (other.type === 0) {
              const dx = other.x - particle.x;
              const dy = other.y - particle.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              if (dist < 10 && Math.random() < SHELLY_NIBBLE_PROBABILITY) {
                let nibbleEfficiency = getTrait(particle, "mainHue", 120);
                let defense = getTrait(other, "subHue", 120);
                let transfer = 2 * nibbleEfficiency / defense;
                transfer *= (other.size / 10);
                other.energy -= transfer;
                addEnergy(particle, transfer);
                particle.predationCue = 30;
                particle.vx = 0;
                particle.vy = 0;
                if (other.energy <= 0) {
                  particles.splice(j, 1);
                }
                break;
              }
            }
          }
        }
        if (particle.type === 1) {
          for (let j = particles.length - 1; j >= 0; j--) {
            let other = particles[j];
            if (other.type === 2) {
              const dx = other.x - particle.x;
              const dy = other.y - particle.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              if (dist < 10 && Math.random() < HAIRY_NIBBLE_PROBABILITY) {
                let nibbleAmount = 5 * (other.size / 10);
                other.energy -= nibbleAmount;
                addEnergy(particle, nibbleAmount);
                particle.predationCue = 30;
                if (other.energy <= 0) {
                  particles.splice(j, 1);
                }
              }
            }
          }
          if (particle.age >= NEWBORN_IMMUNITY_DURATION) {
            for (let other of particles) {
              if (other.type === 2) {
                const dx = particle.x - other.x;
                const dy = particle.y - other.y;
                const d = Math.sqrt(dx * dx + dy * dy);
                if (d < 10 && Math.random() < 0.02) {
                  particle.energy -= 1;
                  particle.predationCue = 30;
                }
              }
            }
          }
          if (particle.age >= NEWBORN_IMMUNITY_DURATION) {
            for (let other of particles) {
              if (other.type === 1 && other !== particle && other.age >= NEWBORN_IMMUNITY_DURATION) {
                const dx = particle.x - other.x;
                const dy = particle.y - other.y;
                const d = Math.sqrt(dx * dx + dy * dy);
                if (d < 20) {
                  let r = Math.random();
                  if (r < HAIRY_VS_HAIRY_DAMAGE_PROBABILITY) {
                    particle.energy -= 5;
                    other.energy -= 5;
                    particle.predationCue = 30;
                    other.predationCue = 30;
                  } else if (r < 0.9) {
                    let repulsionForce = 0.05;
                    particle.vx += (dx / d) * repulsionForce;
                    particle.vy += (dy / d) * repulsionForce;
                    other.vx -= (dx / d) * repulsionForce;
                    other.vy -= (dy / d) * repulsionForce;
                  }
                }
              }
            }
          }
        }
        
        if (particle.type === 1 && Math.random() < 0.005) {
          poops.push(createProcGenPoop(particle.x, particle.y, particle.size));
        } else if (particle.type === 2 && Math.random() < 0.002) {
          poops.push(createProcGenPoop(particle.x, particle.y, particle.size));
        }
        if (particle.type !== 0) {
          for (let poop of poops) {
            const dx = particle.x - poop.x;
            const dy = particle.y - poop.y;
            const d = Math.sqrt(dx * dx + dy * dy);
            if (d < 50 && d > 0) {
              const rep = 0.05 * (1 - d / 50);
              particle.vx += (dx / d) * rep;
              particle.vy += (dy / d) * rep;
            }
          }
          let localPoopCount = 0, sumX = 0, sumY = 0;
          for (let poop of poops) {
            const dx = particle.x - poop.x;
            const dy = particle.y - poop.y;
            const d = Math.sqrt(dx * dx + dy * dy);
            if (d < 50) { localPoopCount++; sumX += poop.x; sumY += poop.y; }
          }
          if (localPoopCount > 3) {
            let extraForce = (localPoopCount - 3) * 0.01;
            let centerX = sumX / localPoopCount, centerY = sumY / localPoopCount;
            let dx = particle.x - centerX, dy = particle.y - centerY;
            let d = Math.sqrt(dx * dx + dy * dy);
            if (d > 0) {
              particle.vx += (dx / d) * extraForce;
              particle.vy += (dy / d) * extraForce;
            }
          }
        } else {
          for (let j = poops.length - 1; j >= 0; j--) {
            let poop = poops[j];
            const dx = particle.x - poop.x;
            const dy = particle.y - poop.y;
            const d = Math.sqrt(dx * dx + dy * dy);
            if (d < 30) {
              poop.lifetime -= 2;
              particle.absorbCue = 30;
              addEnergy(particle, 2);
            }
          }
        }
        
        particleTypes[particle.type].behavior(particle);
        if (particle.type !== 0) {
          let speed = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
          let maxSpeed = 3 / particle.size;
          if (speed > maxSpeed) {
            particle.vx = (particle.vx / speed) * maxSpeed;
            particle.vy = (particle.vy / speed) * maxSpeed;
          }
          particle.x += particle.vx * simulationSpeed;
          particle.y += particle.vy * simulationSpeed;
        }
        if (particle.x < 0) particle.x = worldSize.width;
        if (particle.x > worldSize.width) particle.x = 0;
        if (particle.y < 0) particle.y = worldSize.height;
        if (particle.y > worldSize.height) particle.y = 0;
        
        if (particles.length < maxPopulation &&
            particle.reproductionCooldown <= 0 &&
            particle.age > 200 &&
            (
              (particle.type === 0 && particle.energy >= 50) ||
              (particle.type === 1 && particle.energy >= 60) ||
              (particle.type === 2 && particle.energy >= 80)
            )
           ) {
          particles.push(reproduceParticle(particle));
          if (particle.type === 0) {
            let newCooldown = 250 - ((particle.dna.detailHue - 75) * 100 / 70);
            particle.reproductionCooldown = newCooldown;
            particle.energy -= 20;
          } else if (particle.type === 1) {
            particle.reproductionCooldown = 200;
            particle.energy -= 20;
          } else if (particle.type === 2) {
            particle.reproductionCooldown = 100;
            particle.energy -= 40;
          }
        }
        
        particleTypes[particle.type].draw(ctx, particle.x / zoom, particle.y / zoom, particle);
        if (particle.predationCue > 0) particle.predationCue--;
        if (particle.radiationCue > 0) {
          ctx.save();
          const alpha = particle.radiationCue / 30;
          ctx.strokeStyle = `rgba(255,0,255,${alpha})`;
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(particle.x / zoom, particle.y / zoom, particle.size + 8, 0, 2 * Math.PI);
          ctx.stroke();
          ctx.restore();
          particle.radiationCue--;
        }
        if (particle.type === 0 && particle.absorbCue > 0) {
          ctx.save();
          const alpha = particle.absorbCue / 30;
          ctx.strokeStyle = `rgba(0,255,0,${alpha})`;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(particle.x / zoom, particle.y / zoom, particle.size + 6, 0, 2 * Math.PI);
          ctx.stroke();
          ctx.restore();
          particle.absorbCue--;
        }
      }
      
      particles = particles.filter(p => (p.type === 0) || (p.energy > 0));
      debugDiv.textContent = "Population: " + particles.length;
      if (particles.length === 0) {
        console.warn("Population extinct. Reinitializing...");
        initializeParticles(150);
      }
      if (poops.length > 200) {
        poops.splice(0, poops.length - 200);
      }
      requestAnimationFrame(update);
    }
    update();
    
    /***********************
     * MOUSE & TOUCH TOOLTIP FOR GENE/TRAIT INFO
     ***********************/
    // Define evotrait labels. For Hairy (type 1) we now show four traits.
    const statLabels = {
      0: { main: "Nutrient Value", sub: "Defensive Toughness", detail: "Growth Rate" },
      1: { main: "Behavior (Aggression)", sub: "Agility", detail: "Fighting Persistence", extra: "Spike Combat Efficiency" },
      2: { main: "Nibble Efficiency", sub: "Evasion", detail: "Defensive Resilience" }
    };
    
    function handleTooltip(e) {
      let clientX, clientY;
      if (e.touches && e.touches.length > 0) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
      } else {
        clientX = e.clientX;
        clientY = e.clientY;
      }
      const worldX = clientX * zoom;
      const worldY = clientY * zoom;
      let minDist = Infinity;
      let selected = null;
      for (let particle of particles) {
        const dx = particle.x - worldX;
        const dy = particle.y - worldY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < minDist) { minDist = dist; selected = particle; }
      }
      if (selected && minDist < 15) {
        tooltipDiv.style.display = "block";
        tooltipDiv.style.left = (clientX + 10) + "px";
        tooltipDiv.style.top = (clientY + 10) + "px";
        let typeName = particleTypes[selected.type].name;
        if (selected.type === 1) {
          tooltipDiv.innerHTML =
            `<strong>${typeName}</strong><br>` +
            `Behavior (Aggression): ${selected.dna.mainHue.toFixed(1)}<br>` +
            `Agility: ${selected.dna.subHue.toFixed(1)}<br>` +
            `Fighting Persistence: ${selected.dna.detailHue.toFixed(1)}<br>` +
            `Spike Combat Efficiency: ${selected.dna.spikeHue.toFixed(1)}`;
        } else {
          tooltipDiv.innerHTML =
            `<strong>${typeName}</strong><br>` +
            `${statLabels[selected.type].main}: ${selected.dna.mainHue.toFixed(1)}<br>` +
            `${statLabels[selected.type].sub}: ${selected.dna.subHue.toFixed(1)}<br>` +
            `${statLabels[selected.type].detail}: ${selected.dna.detailHue.toFixed(1)}`;
        }
      } else {
        tooltipDiv.style.display = "none";
      }
    }
    document.addEventListener("mousemove", handleTooltip);
    document.addEventListener("touchstart", handleTooltip);
    document.addEventListener("touchmove", handleTooltip);
    document.addEventListener("touchend", () => { tooltipDiv.style.display = "none"; });
    document.addEventListener("touchcancel", () => { tooltipDiv.style.display = "none"; });
    
  </script>
</body>
</html>
